import Papa from 'papaparse';
import { SalesData, BranchGroup, RawCsvRow } from '../types';

// Helper to determine branch group based on rules
const getBranchGroup = (branchName: string): BranchGroup => {
  const normalized = branchName.toLowerCase();
  if (normalized.includes('moshi') || normalized.includes('ms ')) {
    return BranchGroup.MOSHI;
  }
  if (normalized.includes('b2s')) {
    return BranchGroup.B2S;
  }
  return BranchGroup.WANYEN; // Default as per requirement 7.3
};

// Helper to parse Thai Buddhist Era dates (e.g., 1/11/2568 10:04)
const parseThaiDate = (dateStr: string): Date | null => {
  try {
    if (!dateStr) return null;
    
    // Split date and time
    const [dPart, tPart] = dateStr.split(' ');
    const [day, month, yearBE] = dPart.split('/').map(Number);
    
    // Convert Buddhist Era to Christian Era (subtract 543)
    const yearAD = yearBE - 543;
    
    // Construct a date string compatible with standard parsing
    // Using simple construction to avoid timezone issues for report dates
    const dateObj = new Date(yearAD, month - 1, day);
    
    // Add time if exists
    if (tPart) {
        const [hour, minute] = tPart.split(':').map(Number);
        dateObj.setHours(hour || 0);
        dateObj.setMinutes(minute || 0);
    }

    // Check if date is valid using native method instead of date-fns isValid
    return !isNaN(dateObj.getTime()) ? dateObj : null;
  } catch (e) {
    console.error("Error parsing date:", dateStr, e);
    return null;
  }
};

export const parseCSV = (file: File): Promise<SalesData[]> => {
  return new Promise((resolve, reject) => {
    Papa.parse<RawCsvRow>(file, {
      header: true,
      skipEmptyLines: true,
      complete: (results) => {
        const parsedData: SalesData[] = results.data
          .filter(row => row['วันที่'] && row['ยอดรวม']) // Filter empty rows or footer totals
          .map((row, index) => {
            const date = parseThaiDate(row['วันที่']);
            const quantity = parseFloat(row['จำนวน']?.replace(/,/g, '') || '0');
            const totalSales = parseFloat(row['ยอดรวม']?.replace(/,/g, '') || '0');
            const branch = row['branch'] || 'Unknown';

            if (!date) return null;

            return {
              id: `row-${index}`,
              date: date,
              product: row['สินค้า'] || 'Unknown',
              quantity: quantity,
              totalSales: totalSales,
              paymentMethod: row['payment'] || 'Unknown',
              branch: branch,
              branchGroup: getBranchGroup(branch)
            };
          })
          .filter((item): item is SalesData => item !== null);

        resolve(parsedData);
      },
      error: (error) => {
        reject(error);
      }
    });
  });
};
