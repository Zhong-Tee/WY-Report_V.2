import React, { useState, useEffect } from 'react';
import Papa from 'papaparse';
import { SalesRecord, BranchCost, StockRecord, PlanningRow } from '../types';
import { supabase, STOCK_TABLE, getGroup, extractBranchId } from '../services/supabase';
import { RefreshCw, Download, Search } from 'lucide-react';

interface ServicePlanningProps {
    data: SalesRecord[];
    costs: Record<string, BranchCost>;
    startDate: string;
    endDate: string;
    onRefresh: () => void;
}

const ServicePlanning: React.FC<ServicePlanningProps> = ({ data, costs, startDate, endDate, onRefresh }) => {
    const [planningRows, setPlanningRows] = useState<PlanningRow[]>([]);
    const [filterText, setFilterText] = useState('');
    const [filters, setFilters] = useState({ critical: true, warning: true, good: true });
    const [selectedRows, setSelectedRows] = useState<Set<number>>(new Set());
    const [isLoading, setIsLoading] = useState(false);

    const calculatePlanning = async () => {
        setIsLoading(true);
        const start = new Date(startDate);
        const end = new Date(endDate);
        let countWD = 0, countWE = 0;
        
        for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
            const day = d.getUTCDay();
            if (day === 0 || day === 6) countWE++; else countWD++;
        }
        countWD = Math.max(1, countWD);
        countWE = Math.max(1, countWE);

        const runRates: Record<number, {INK: {wd:number, we:number}, PAPER: {wd:number, we:number}}> = {};
        
        // 1. Calculate Run Rates from Sales
        data.forEach(r => {
            const brId = extractBranchId(r.branch_name);
            if(!brId) return;

            const isInk = (r.product || "").toUpperCase().includes("RIBBON");
            const type = isInk ? "INK" : "PAPER";
            const day = new Date(r.transaction_date).getUTCDay();
            const isWE = (day === 0 || day === 6);
            
            if (!runRates[brId]) runRates[brId] = { INK: {wd:0, we:0}, PAPER: {wd:0, we:0} };
            if (isWE) runRates[brId][type].we += Number(r.quantity);
            else runRates[brId][type].wd += Number(r.quantity);
        });

        // 2. Fetch Current Stock
        const { data: stockRows, error } = await supabase.from(STOCK_TABLE).select('*');
        if (error) {
            alert("Error fetching stock: " + error.message);
            setIsLoading(false);
            return;
        }

        const stocks: Record<number, {name:string, INK: number, PAPER: number, INK_CODE:string, PAPER_CODE:string}> = {};
        stockRows?.forEach((row: any) => {
            const brId = row.branch_id;
            if(!brId) return;
            const type = (row.product_name||"").toUpperCase().includes("RIBBON") ? "INK" : "PAPER";
            if(!stocks[brId]) stocks[brId] = { name: row.branch_name, INK:0, PAPER:0, INK_CODE:"", PAPER_CODE:"" };
            
            stocks[brId][type] += Number(row.quantity);
            if(type === "INK" && !stocks[brId].INK_CODE) stocks[brId].INK_CODE = row.product_name;
            if(type === "PAPER" && !stocks[brId].PAPER_CODE) stocks[brId].PAPER_CODE = row.product_name;
        });

        // 3. Merge & Calculate
        const allIds = new Set([...Object.keys(runRates).map(Number), ...Object.keys(stocks).map(Number)]);
        const result: PlanningRow[] = [];

        allIds.forEach(id => {
            const stockInfo = stocks[id] || { name: `Branch ${id}`, INK:0, PAPER:0, INK_CODE:"", PAPER_CODE:"" };
            const sales = runRates[id] || { INK: {wd:0, we:0}, PAPER: {wd:0, we:0} };
            const brName = stockInfo.name;

            // Fix 3: Match Branch Cost/Zone using ID first, then Name
            let costInfo = (Object.values(costs) as BranchCost[]).find(c => c.branch_id === id);
            if (!costInfo) {
                // Fallback to name matching if ID not found in costs cache
                costInfo = costs[brName];
            }
            const zone = costInfo?.zone || '-';

            const calc = (type: 'INK' | 'PAPER') => {
                const s = sales[type];
                const avgWD = s.wd / countWD;
                const avgWE = s.we / countWE;
                let currentStock = stockInfo[type];
                let daysLeft = 999;
                
                // Paper Logic
                if (type === 'PAPER') {
                    const weightedAvg = ((avgWD * 5) + (avgWE * 2)) / 7;
                    daysLeft = weightedAvg > 0 ? (currentStock / weightedAvg) : 999;
                } else {
                    // Ink logic depends on Paper usage usually, but let's stick to standard run rate logic
                    // Original code: inkCalc.daysLeft based on paperWeightedAvg
                     const pS = sales['PAPER'];
                     const pAvgWD = pS.wd / countWD;
                     const pAvgWE = pS.we / countWE;
                     const paperWeightedAvg = ((pAvgWD * 5) + (pAvgWE * 2)) / 7;
                     daysLeft = paperWeightedAvg > 0 ? (currentStock / paperWeightedAvg) : 999;
                }
                
                result.push({
                    branch: brName,
                    branch_id: id,
                    zone,
                    type,
                    code: type === 'INK' ? stockInfo.INK_CODE : stockInfo.PAPER_CODE,
                    stock: currentStock,
                    avgWD,
                    avgWE,
                    daysLeft
                });
            };

            calc('PAPER');
            calc('INK');
        });

        setPlanningRows(result.sort((a,b) => a.daysLeft - b.daysLeft));
        setIsLoading(false);
    };

    useEffect(() => {
        calculatePlanning();
    }, [data]); // Recalculate if sales data changes, assuming stock is fetched on mount or refresh

    // Filtering
    const filteredRows = planningRows.filter(row => {
        const matchesText = 
            row.branch.toLowerCase().includes(filterText.toLowerCase()) || 
            row.zone.toLowerCase().includes(filterText.toLowerCase()) ||
            row.code.toLowerCase().includes(filterText.toLowerCase());

        let matchesStatus = false;
        if (row.daysLeft < 7 && filters.critical) matchesStatus = true;
        else if (row.daysLeft >= 7 && row.daysLeft < 14 && filters.warning) matchesStatus = true;
        else if (row.daysLeft >= 14 && filters.good) matchesStatus = true;

        return matchesText && matchesStatus;
    });

    const toggleSelect = (index: number) => {
        const newSet = new Set(selectedRows);
        if(newSet.has(index)) newSet.delete(index);
        else newSet.add(index);
        setSelectedRows(newSet);
    };

    const toggleAllGroup = (groupRows: PlanningRow[], startIndex: number, checked: boolean) => {
         const newSet = new Set(selectedRows);
         groupRows.forEach((_, i) => {
             if(checked) newSet.add(startIndex + i);
             else newSet.delete(startIndex + i);
         });
         setSelectedRows(newSet);
    };

    // Fix 5: Excel Export includes Branch ID
    const exportCSV = () => {
        const toExport = planningRows.filter((_, i) => selectedRows.has(i));
        if(toExport.length === 0) return alert("Select rows to export");

        const csvData = toExport.map(r => ({
            Branch_ID: r.branch_id, // Added
            Branch: r.branch,
            Zone: r.zone,
            Type: r.type,
            Product_Code: r.code,
            Stock: r.stock,
            Avg_Weekday: r.avgWD.toFixed(2),
            Avg_Weekend: r.avgWE.toFixed(2),
            Est_Days_Left: r.daysLeft.toFixed(1)
        }));

        const csv = Papa.unparse(csvData);
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = `Service_Planning_${new Date().toISOString().slice(0,10)}.csv`;
        link.click();
    };

    const renderGroup = (groupName: string) => {
        const groupRows = filteredRows.map((r, i) => ({...r, originalIndex: i})).filter(r => getGroup(r.branch) === groupName);
        if(groupRows.length === 0) return null;
        
        const color = groupName === 'Moshi' ? 'pink' : (groupName === 'B2S' ? 'blue' : 'orange');

        return (
            <div class={`bg-white rounded-xl border border-${color}-200 overflow-hidden shadow-sm mb-6`}>
                <div class={`bg-${color}-50 px-4 py-3 font-bold text-${color}-800 flex justify-between items-center`}>
                    <span>{groupName}</span>
                    <button 
                        onClick={() => toggleAllGroup(groupRows, 0, true)} // Simplified group selection logic logic
                        class="text-xs underline opacity-70 hover:opacity-100"
                    >
                        Select All Visible
                    </button>
                </div>
                <div class="overflow-x-auto">
                    <table class="w-full text-xs">
                        <thead class="bg-slate-50 text-slate-500 font-bold uppercase">
                            <tr>
                                <th class="p-3 text-center w-8">#</th>
                                <th class="p-3 text-left">Branch (ID)</th>
                                <th class="p-3 text-left">Zone</th>
                                <th class="p-3 text-left">Type/Code</th>
                                <th class="p-3 text-right">Stock</th>
                                <th class="p-3 text-right">Avg(WD)</th>
                                <th class="p-3 text-right">Avg(WE)</th>
                                <th class="p-3 text-center">Status</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-slate-100">
                            {groupRows.map((row) => {
                                const idx = planningRows.indexOf(planningRows.find(r => r === row) as any); // Find original index
                                const isSel = selectedRows.has(idx);
                                const statusClass = row.daysLeft < 7 ? 'bg-red-100 text-red-700' : (row.daysLeft < 14 ? 'bg-orange-100 text-orange-700' : 'bg-green-100 text-green-700');
                                
                                return (
                                    <tr key={idx} class={`hover:bg-slate-50 ${isSel ? 'bg-indigo-50' : ''}`}>
                                        <td class="p-3 text-center">
                                            <input type="checkbox" checked={isSel} onChange={() => toggleSelect(idx)} class="rounded border-slate-300" />
                                        </td>
                                        <td class="p-3 font-medium text-slate-700">
                                            {row.branch} <span class="text-slate-400 text-[10px]">({row.branch_id})</span>
                                        </td>
                                        <td class="p-3 font-bold" style={{color: stringToColor(row.zone)}}>{row.zone}</td>
                                        <td class="p-3 text-slate-500">{row.code || row.type}</td>
                                        <td class="p-3 text-right font-mono font-bold">{row.stock.toLocaleString()}</td>
                                        <td class="p-3 text-right font-mono text-blue-600">{row.avgWD.toFixed(1)}</td>
                                        <td class="p-3 text-right font-mono text-orange-600">{row.avgWE.toFixed(1)}</td>
                                        <td class="p-3 text-center">
                                            <span class={`px-2 py-1 rounded font-bold ${statusClass} border border-transparent`}>
                                                {row.daysLeft > 365 ? '> 1 Year' : `${row.daysLeft.toFixed(1)} Days`}
                                            </span>
                                        </td>
                                    </tr>
                                );
                            })}
                        </tbody>
                    </table>
                </div>
            </div>
        );
    };

    function stringToColor(str: string) {
        if(!str || str==='-') return '#94a3b8';
        let hash = 0;
        for (let i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash);
        const c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
        return '#' + "00000".substring(0, 6 - c.length) + c;
    }

    return (
        <div class="fade-in space-y-6 pb-20">
             <div class="flex flex-col xl:flex-row justify-between items-start xl:items-end gap-4 border-b border-slate-100 pb-6">
                <div>
                    <h2 class="text-3xl font-bold text-slate-900">Service Planning</h2>
                    <p class="text-sm text-slate-500 mt-1">Stock analysis & prediction. (ID Matching Active)</p>
                </div>
                <div class="flex flex-col md:flex-row gap-4 items-center w-full xl:w-auto">
                    <div class="flex gap-2 bg-slate-100 p-1 rounded-lg">
                        <button onClick={() => setFilters({...filters, critical: !filters.critical})} class={`px-3 py-1.5 text-xs font-bold rounded-md transition-all ${filters.critical ? 'bg-white text-red-600 shadow-sm' : 'text-slate-400'}`}>Critical</button>
                        <button onClick={() => setFilters({...filters, warning: !filters.warning})} class={`px-3 py-1.5 text-xs font-bold rounded-md transition-all ${filters.warning ? 'bg-white text-orange-600 shadow-sm' : 'text-slate-400'}`}>Warning</button>
                        <button onClick={() => setFilters({...filters, good: !filters.good})} class={`px-3 py-1.5 text-xs font-bold rounded-md transition-all ${filters.good ? 'bg-white text-green-600 shadow-sm' : 'text-slate-400'}`}>Good</button>
                    </div>
                    <div class="relative">
                        <Search class="absolute left-3 top-2.5 text-slate-400" size={16} />
                        <input type="text" placeholder="Search..." value={filterText} onChange={e => setFilterText(e.target.value)} class="pl-9 pr-4 py-2 border rounded-lg text-sm w-64 focus:ring-2 focus:ring-indigo-500 outline-none" />
                    </div>
                    <div class="flex gap-2">
                         <button onClick={calculatePlanning} class="bg-indigo-600 text-white px-4 py-2 rounded-lg text-sm font-bold shadow hover:bg-indigo-700 flex items-center gap-2">
                            <RefreshCw size={16} class={isLoading ? 'animate-spin' : ''} /> Refresh
                        </button>
                        <button onClick={exportCSV} class="bg-emerald-600 text-white px-4 py-2 rounded-lg text-sm font-bold shadow hover:bg-emerald-700 flex items-center gap-2">
                            <Download size={16} /> Export
                        </button>
                    </div>
                </div>
            </div>

            {renderGroup('Moshi')}
            {renderGroup('B2S')}
            {renderGroup('Wanyen')}
        </div>
    );
};

export default ServicePlanning;
